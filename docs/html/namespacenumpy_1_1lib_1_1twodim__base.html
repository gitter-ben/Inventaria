<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Inventaria: numpy.lib.twodim_base Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Inventaria
   </div>
   <div id="projectbrief">A lightweight inventory keeping program</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>numpy</b></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html">twodim_base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">numpy.lib.twodim_base Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f41aaea32e91fb7452fae3c58927b1f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a2f41aaea32e91fb7452fae3c58927b1f">fliplr</a> (m)</td></tr>
<tr class="separator:a2f41aaea32e91fb7452fae3c58927b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ed22c6334be41a34f97257be3ff2ed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a33ed22c6334be41a34f97257be3ff2ed">flipud</a> (m)</td></tr>
<tr class="separator:a33ed22c6334be41a34f97257be3ff2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af423582d39bd8eb5be1f00dc3d7f14c1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#af423582d39bd8eb5be1f00dc3d7f14c1">eye</a> (N, M=None, k=0, dtype=float, order='C', *like=None)</td></tr>
<tr class="separator:af423582d39bd8eb5be1f00dc3d7f14c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c9fa6bbfe9e559e90c311d320b49f3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#ab5c9fa6bbfe9e559e90c311d320b49f3">diag</a> (v, k=0)</td></tr>
<tr class="separator:ab5c9fa6bbfe9e559e90c311d320b49f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e76d5ad9a99bf0dfbc11ec1eec8a733"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a2e76d5ad9a99bf0dfbc11ec1eec8a733">diagflat</a> (v, k=0)</td></tr>
<tr class="separator:a2e76d5ad9a99bf0dfbc11ec1eec8a733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db9bfd90644427bb9edd0091c7fcfb3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a1db9bfd90644427bb9edd0091c7fcfb3">tri</a> (N, M=None, k=0, dtype=float, *like=None)</td></tr>
<tr class="separator:a1db9bfd90644427bb9edd0091c7fcfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25994ec2771961d49aa773b59f6d8674"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a25994ec2771961d49aa773b59f6d8674">tril</a> (m, k=0)</td></tr>
<tr class="separator:a25994ec2771961d49aa773b59f6d8674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c5f72467e0719ef3b6e8e9a1aad2cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#ad4c5f72467e0719ef3b6e8e9a1aad2cd">triu</a> (m, k=0)</td></tr>
<tr class="separator:ad4c5f72467e0719ef3b6e8e9a1aad2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aaf8cbe0cc568d958fd0ec603b94677"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a2aaf8cbe0cc568d958fd0ec603b94677">vander</a> (x, N=None, increasing=False)</td></tr>
<tr class="separator:a2aaf8cbe0cc568d958fd0ec603b94677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3f409a160ad5b4ecb0f48244aec2fb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#aed3f409a160ad5b4ecb0f48244aec2fb">histogram2d</a> (x, y, bins=10, range=None, density=None, weights=None)</td></tr>
<tr class="separator:aed3f409a160ad5b4ecb0f48244aec2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1475cbe0d8625d39a2e2a3b91dc0a44f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a1475cbe0d8625d39a2e2a3b91dc0a44f">mask_indices</a> (n, mask_func, k=0)</td></tr>
<tr class="separator:a1475cbe0d8625d39a2e2a3b91dc0a44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b716112412d6d2a7d5c6d62479ab0f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a2b716112412d6d2a7d5c6d62479ab0f8">tril_indices</a> (n, k=0, m=None)</td></tr>
<tr class="separator:a2b716112412d6d2a7d5c6d62479ab0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3be40e3614389bdaded615b72aa5e0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#acf3be40e3614389bdaded615b72aa5e0">tril_indices_from</a> (arr, k=0)</td></tr>
<tr class="separator:acf3be40e3614389bdaded615b72aa5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a38f5d340ce47aebc8046a4d7d57d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#ab3a38f5d340ce47aebc8046a4d7d57d7">triu_indices</a> (n, k=0, m=None)</td></tr>
<tr class="separator:ab3a38f5d340ce47aebc8046a4d7d57d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa286c33b12fe305ea9ead63f3f25f38"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#aaa286c33b12fe305ea9ead63f3f25f38">triu_indices_from</a> (arr, k=0)</td></tr>
<tr class="separator:aaa286c33b12fe305ea9ead63f3f25f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a12fefeaaa42281321c1a4d46f5466e78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>array_function_dispatch</b></td></tr>
<tr class="separator:a12fefeaaa42281321c1a4d46f5466e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cfcadf2383c62ad7ab2416c9d6be56"><td class="memItemLeft" align="right" valign="top"><a id="a06cfcadf2383c62ad7ab2416c9d6be56"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>i1</b> = <a class="el" href="classnumpy_1_1core_1_1getlimits_1_1iinfo.html">iinfo</a>(int8)</td></tr>
<tr class="separator:a06cfcadf2383c62ad7ab2416c9d6be56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faf902c5cb76b708ad9b9b7817e6fee"><td class="memItemLeft" align="right" valign="top"><a id="a1faf902c5cb76b708ad9b9b7817e6fee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>i2</b> = <a class="el" href="classnumpy_1_1core_1_1getlimits_1_1iinfo.html">iinfo</a>(int16)</td></tr>
<tr class="separator:a1faf902c5cb76b708ad9b9b7817e6fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f21f9684d5a55768287866e474514f7"><td class="memItemLeft" align="right" valign="top"><a id="a5f21f9684d5a55768287866e474514f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>i4</b> = <a class="el" href="classnumpy_1_1core_1_1getlimits_1_1iinfo.html">iinfo</a>(int32)</td></tr>
<tr class="separator:a5f21f9684d5a55768287866e474514f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment"> Basic functions for manipulating 2d arrays</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ab5c9fa6bbfe9e559e90c311d320b49f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c9fa6bbfe9e559e90c311d320b49f3">&#9670;&nbsp;</a></span>diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.diag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract a diagonal or construct a diagonal array.

See the more detailed documentation for ``numpy.diagonal`` if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.

Parameters
----------
v : array_like
    If `v` is a 2-D array, return a copy of its `k`-th diagonal.
    If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th
    diagonal.
k : int, optional
    Diagonal in question. The default is 0. Use `k&gt;0` for diagonals
    above the main diagonal, and `k&lt;0` for diagonals below the main
    diagonal.

Returns
-------
out : ndarray
    The extracted diagonal or constructed diagonal array.

See Also
--------
diagonal : Return specified diagonals.
diagflat : Create a 2-D array with the flattened input as a diagonal.
trace : Sum along diagonals.
triu : Upper triangle of an array.
tril : Lower triangle of an array.

Examples
--------
&gt;&gt;&gt; x = np.arange(9).reshape((3,3))
&gt;&gt;&gt; x
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

&gt;&gt;&gt; np.diag(x)
array([0, 4, 8])
&gt;&gt;&gt; np.diag(x, k=1)
array([1, 5])
&gt;&gt;&gt; np.diag(x, k=-1)
array([3, 7])

&gt;&gt;&gt; np.diag(np.diag(x))
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 8]])</pre> 
</div>
</div>
<a id="a2e76d5ad9a99bf0dfbc11ec1eec8a733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e76d5ad9a99bf0dfbc11ec1eec8a733">&#9670;&nbsp;</a></span>diagflat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.diagflat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a two-dimensional array with the flattened input as a diagonal.

Parameters
----------
v : array_like
    Input data, which is flattened and set as the `k`-th
    diagonal of the output.
k : int, optional
    Diagonal to set; 0, the default, corresponds to the "main" diagonal,
    a positive (negative) `k` giving the number of the diagonal above
    (below) the main.

Returns
-------
out : ndarray
    The 2-D output array.

See Also
--------
diag : MATLAB work-alike for 1-D and 2-D arrays.
diagonal : Return specified diagonals.
trace : Sum along diagonals.

Examples
--------
&gt;&gt;&gt; np.diagflat([[1,2], [3,4]])
array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])

&gt;&gt;&gt; np.diagflat([1,2], 1)
array([[0, 1, 0],
       [0, 0, 2],
       [0, 0, 0]])</pre> 
</div>
</div>
<a id="af423582d39bd8eb5be1f00dc3d7f14c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af423582d39bd8eb5be1f00dc3d7f14c1">&#9670;&nbsp;</a></span>eye()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.eye </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>float</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'C'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>like</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a 2-D array with ones on the diagonal and zeros elsewhere.

Parameters
----------
N : int
  Number of rows in the output.
M : int, optional
  Number of columns in the output. If None, defaults to `N`.
k : int, optional
  Index of the diagonal: 0 (the default) refers to the main diagonal,
  a positive value refers to an upper diagonal, and a negative value
  to a lower diagonal.
dtype : data-type, optional
  Data-type of the returned array.
order : {'C', 'F'}, optional
    Whether the output should be stored in row-major (C-style) or
    column-major (Fortran-style) order in memory.

    .. versionadded:: 1.14.0
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
I : ndarray of shape (N,M)
  An array where all elements are equal to zero, except for the `k`-th
  diagonal, whose values are equal to one.

See Also
--------
identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.

Examples
--------
&gt;&gt;&gt; np.eye(2, dtype=int)
array([[1, 0],
       [0, 1]])
&gt;&gt;&gt; np.eye(3, k=1)
array([[0.,  1.,  0.],
       [0.,  0.,  1.],
       [0.,  0.,  0.]])</pre> 
</div>
</div>
<a id="a2f41aaea32e91fb7452fae3c58927b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f41aaea32e91fb7452fae3c58927b1f">&#9670;&nbsp;</a></span>fliplr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.fliplr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reverse the order of elements along axis 1 (left/right).

For a 2-D array, this flips the entries in each row in the left/right
direction. Columns are preserved, but appear in a different order than
before.

Parameters
----------
m : array_like
    Input array, must be at least 2-D.

Returns
-------
f : ndarray
    A view of `m` with the columns reversed.  Since a view
    is returned, this operation is :math:`\\mathcal O(1)`.

See Also
--------
flipud : Flip array in the up/down direction.
flip : Flip array in one or more dimensions.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to ``m[:,::-1]`` or ``np.flip(m, axis=1)``.
Requires the array to be at least 2-D.

Examples
--------
&gt;&gt;&gt; A = np.diag([1.,2.,3.])
&gt;&gt;&gt; A
array([[1.,  0.,  0.],
       [0.,  2.,  0.],
       [0.,  0.,  3.]])
&gt;&gt;&gt; np.fliplr(A)
array([[0.,  0.,  1.],
       [0.,  2.,  0.],
       [3.,  0.,  0.]])

&gt;&gt;&gt; A = np.random.randn(2,3,5)
&gt;&gt;&gt; np.all(np.fliplr(A) == A[:,::-1,...])
True</pre> 
</div>
</div>
<a id="a33ed22c6334be41a34f97257be3ff2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ed22c6334be41a34f97257be3ff2ed">&#9670;&nbsp;</a></span>flipud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.flipud </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reverse the order of elements along axis 0 (up/down).

For a 2-D array, this flips the entries in each column in the up/down
direction. Rows are preserved, but appear in a different order than before.

Parameters
----------
m : array_like
    Input array.

Returns
-------
out : array_like
    A view of `m` with the rows reversed.  Since a view is
    returned, this operation is :math:`\\mathcal O(1)`.

See Also
--------
fliplr : Flip array in the left/right direction.
flip : Flip array in one or more dimensions.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to ``m[::-1, ...]`` or ``np.flip(m, axis=0)``.
Requires the array to be at least 1-D.

Examples
--------
&gt;&gt;&gt; A = np.diag([1.0, 2, 3])
&gt;&gt;&gt; A
array([[1.,  0.,  0.],
       [0.,  2.,  0.],
       [0.,  0.,  3.]])
&gt;&gt;&gt; np.flipud(A)
array([[0.,  0.,  3.],
       [0.,  2.,  0.],
       [1.,  0.,  0.]])

&gt;&gt;&gt; A = np.random.randn(2,3,5)
&gt;&gt;&gt; np.all(np.flipud(A) == A[::-1,...])
True

&gt;&gt;&gt; np.flipud([1,2])
array([2, 1])</pre> 
</div>
</div>
<a id="aed3f409a160ad5b4ecb0f48244aec2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3f409a160ad5b4ecb0f48244aec2fb">&#9670;&nbsp;</a></span>histogram2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.histogram2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>density</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the bi-dimensional histogram of two data samples.

Parameters
----------
x : array_like, shape (N,)
    An array containing the x coordinates of the points to be
    histogrammed.
y : array_like, shape (N,)
    An array containing the y coordinates of the points to be
    histogrammed.
bins : int or array_like or [int, int] or [array, array], optional
    The bin specification:

      * If int, the number of bins for the two dimensions (nx=ny=bins).
      * If array_like, the bin edges for the two dimensions
        (x_edges=y_edges=bins).
      * If [int, int], the number of bins in each dimension
        (nx, ny = bins).
      * If [array, array], the bin edges in each dimension
        (x_edges, y_edges = bins).
      * A combination [int, array] or [array, int], where int
        is the number of bins and array is the bin edges.

range : array_like, shape(2,2), optional
    The leftmost and rightmost edges of the bins along each dimension
    (if not specified explicitly in the `bins` parameters):
    ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range
    will be considered outliers and not tallied in the histogram.
density : bool, optional
    If False, the default, returns the number of samples in each bin.
    If True, returns the probability *density* function at the bin,
    ``bin_count / sample_count / bin_area``.
weights : array_like, shape(N,), optional
    An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.
    Weights are normalized to 1 if `density` is True. If `density` is
    False, the values of the returned histogram are equal to the sum of
    the weights belonging to the samples falling into each bin.

Returns
-------
H : ndarray, shape(nx, ny)
    The bi-dimensional histogram of samples `x` and `y`. Values in `x`
    are histogrammed along the first dimension and values in `y` are
    histogrammed along the second dimension.
xedges : ndarray, shape(nx+1,)
    The bin edges along the first dimension.
yedges : ndarray, shape(ny+1,)
    The bin edges along the second dimension.

See Also
--------
histogram : 1D histogram
histogramdd : Multidimensional histogram

Notes
-----
When `density` is True, then the returned histogram is the sample
density, defined such that the sum over bins of the product
``bin_value * bin_area`` is 1.

Please note that the histogram does not follow the Cartesian convention
where `x` values are on the abscissa and `y` values on the ordinate
axis.  Rather, `x` is histogrammed along the first dimension of the
array (vertical), and `y` along the second dimension of the array
(horizontal).  This ensures compatibility with `histogramdd`.

Examples
--------
&gt;&gt;&gt; from matplotlib.image import NonUniformImage
&gt;&gt;&gt; import matplotlib.pyplot as plt

Construct a 2-D histogram with variable bin width. First define the bin
edges:

&gt;&gt;&gt; xedges = [0, 1, 3, 5]
&gt;&gt;&gt; yedges = [0, 2, 3, 4, 6]

Next we create a histogram H with random bin content:

&gt;&gt;&gt; x = np.random.normal(2, 1, 100)
&gt;&gt;&gt; y = np.random.normal(1, 1, 100)
&gt;&gt;&gt; H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))
&gt;&gt;&gt; # Histogram does not follow Cartesian convention (see Notes),
&gt;&gt;&gt; # therefore transpose H for visualization purposes.
&gt;&gt;&gt; H = H.T

:func:`imshow &lt;matplotlib.pyplot.imshow&gt;` can only display square bins:

&gt;&gt;&gt; fig = plt.figure(figsize=(7, 3))
&gt;&gt;&gt; ax = fig.add_subplot(131, title='imshow: square bins')
&gt;&gt;&gt; plt.imshow(H, interpolation='nearest', origin='lower',
...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])
&lt;matplotlib.image.AxesImage object at 0x...&gt;

:func:`pcolormesh &lt;matplotlib.pyplot.pcolormesh&gt;` can display actual edges:

&gt;&gt;&gt; ax = fig.add_subplot(132, title='pcolormesh: actual edges',
...         aspect='equal')
&gt;&gt;&gt; X, Y = np.meshgrid(xedges, yedges)
&gt;&gt;&gt; ax.pcolormesh(X, Y, H)
&lt;matplotlib.collections.QuadMesh object at 0x...&gt;

:class:`NonUniformImage &lt;matplotlib.image.NonUniformImage&gt;` can be used to
display actual bin edges with interpolation:

&gt;&gt;&gt; ax = fig.add_subplot(133, title='NonUniformImage: interpolated',
...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])
&gt;&gt;&gt; im = NonUniformImage(ax, interpolation='bilinear')
&gt;&gt;&gt; xcenters = (xedges[:-1] + xedges[1:]) / 2
&gt;&gt;&gt; ycenters = (yedges[:-1] + yedges[1:]) / 2
&gt;&gt;&gt; im.set_data(xcenters, ycenters, H)
&gt;&gt;&gt; ax.add_image(im)
&gt;&gt;&gt; plt.show()

It is also possible to construct a 2-D histogram without specifying bin
edges:

&gt;&gt;&gt; # Generate non-symmetric test data
&gt;&gt;&gt; n = 10000
&gt;&gt;&gt; x = np.linspace(1, 100, n)
&gt;&gt;&gt; y = 2*np.log(x) + np.random.rand(n) - 0.5
&gt;&gt;&gt; # Compute 2d histogram. Note the order of x/y and xedges/yedges
&gt;&gt;&gt; H, yedges, xedges = np.histogram2d(y, x, bins=20)

Now we can plot the histogram using
:func:`pcolormesh &lt;matplotlib.pyplot.pcolormesh&gt;`, and a
:func:`hexbin &lt;matplotlib.pyplot.hexbin&gt;` for comparison.

&gt;&gt;&gt; # Plot histogram using pcolormesh
&gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(ncols=2, sharey=True)
&gt;&gt;&gt; ax1.pcolormesh(xedges, yedges, H, cmap='rainbow')
&gt;&gt;&gt; ax1.plot(x, 2*np.log(x), 'k-')
&gt;&gt;&gt; ax1.set_xlim(x.min(), x.max())
&gt;&gt;&gt; ax1.set_ylim(y.min(), y.max())
&gt;&gt;&gt; ax1.set_xlabel('x')
&gt;&gt;&gt; ax1.set_ylabel('y')
&gt;&gt;&gt; ax1.set_title('histogram2d')
&gt;&gt;&gt; ax1.grid()

&gt;&gt;&gt; # Create hexbin plot for comparison
&gt;&gt;&gt; ax2.hexbin(x, y, gridsize=20, cmap='rainbow')
&gt;&gt;&gt; ax2.plot(x, 2*np.log(x), 'k-')
&gt;&gt;&gt; ax2.set_title('hexbin')
&gt;&gt;&gt; ax2.set_xlim(x.min(), x.max())
&gt;&gt;&gt; ax2.set_xlabel('x')
&gt;&gt;&gt; ax2.grid()

&gt;&gt;&gt; plt.show()
</pre> 
</div>
</div>
<a id="a1475cbe0d8625d39a2e2a3b91dc0a44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1475cbe0d8625d39a2e2a3b91dc0a44f">&#9670;&nbsp;</a></span>mask_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.mask_indices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices to access (n, n) arrays, given a masking function.

Assume `mask_func` is a function that, for a square array a of size
``(n, n)`` with a possible offset argument `k`, when called as
``mask_func(a, k)`` returns a new array with zeros in certain locations
(functions like `triu` or `tril` do precisely this). Then this function
returns the indices where the non-zero values would be located.

Parameters
----------
n : int
    The returned indices will be valid to access arrays of shape (n, n).
mask_func : callable
    A function whose call signature is similar to that of `triu`, `tril`.
    That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.
    `k` is an optional argument to the function.
k : scalar
    An optional argument which is passed through to `mask_func`. Functions
    like `triu`, `tril` take a second argument that is interpreted as an
    offset.

Returns
-------
indices : tuple of arrays.
    The `n` arrays of indices corresponding to the locations where
    ``mask_func(np.ones((n, n)), k)`` is True.

See Also
--------
triu, tril, triu_indices, tril_indices

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
These are the indices that would allow you to access the upper triangular
part of any 3x3 array:

&gt;&gt;&gt; iu = np.mask_indices(3, np.triu)

For example, if `a` is a 3x3 array:

&gt;&gt;&gt; a = np.arange(9).reshape(3, 3)
&gt;&gt;&gt; a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
&gt;&gt;&gt; a[iu]
array([0, 1, 2, 4, 5, 8])

An offset can be passed also to the masking function.  This gets us the
indices starting on the first diagonal right of the main one:

&gt;&gt;&gt; iu1 = np.mask_indices(3, np.triu, 1)

with which we now extract only three elements:

&gt;&gt;&gt; a[iu1]
array([1, 2, 5])</pre> 
</div>
</div>
<a id="a1db9bfd90644427bb9edd0091c7fcfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db9bfd90644427bb9edd0091c7fcfb3">&#9670;&nbsp;</a></span>tri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.tri </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>float</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>like</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An array with ones at and below the given diagonal and zeros elsewhere.

Parameters
----------
N : int
    Number of rows in the array.
M : int, optional
    Number of columns in the array.
    By default, `M` is taken equal to `N`.
k : int, optional
    The sub-diagonal at and below which the array is filled.
    `k` = 0 is the main diagonal, while `k` &lt; 0 is below it,
    and `k` &gt; 0 is above.  The default is 0.
dtype : dtype, optional
    Data type of the returned array.  The default is float.
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
tri : ndarray of shape (N, M)
    Array with its lower triangle filled with ones and zero elsewhere;
    in other words ``T[i,j] == 1`` for ``j &lt;= i + k``, 0 otherwise.

Examples
--------
&gt;&gt;&gt; np.tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1]])

&gt;&gt;&gt; np.tri(3, 5, -1)
array([[0.,  0.,  0.,  0.,  0.],
       [1.,  0.,  0.,  0.,  0.],
       [1.,  1.,  0.,  0.,  0.]])</pre> 
</div>
</div>
<a id="a25994ec2771961d49aa773b59f6d8674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25994ec2771961d49aa773b59f6d8674">&#9670;&nbsp;</a></span>tril()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.tril </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Lower triangle of an array.

Return a copy of an array with elements above the `k`-th diagonal zeroed.
For arrays with ``ndim`` exceeding 2, `tril` will apply to the final two
axes.

Parameters
----------
m : array_like, shape (..., M, N)
    Input array.
k : int, optional
    Diagonal above which to zero elements.  `k = 0` (the default) is the
    main diagonal, `k &lt; 0` is below it and `k &gt; 0` is above.

Returns
-------
tril : ndarray, shape (..., M, N)
    Lower triangle of `m`, of same shape and data-type as `m`.

See Also
--------
triu : same thing, only for the upper triangle

Examples
--------
&gt;&gt;&gt; np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
       [ 4,  0,  0],
       [ 7,  8,  0],
       [10, 11, 12]])

&gt;&gt;&gt; np.tril(np.arange(3*4*5).reshape(3, 4, 5))
array([[[ 0,  0,  0,  0,  0],
        [ 5,  6,  0,  0,  0],
        [10, 11, 12,  0,  0],
        [15, 16, 17, 18,  0]],
       [[20,  0,  0,  0,  0],
        [25, 26,  0,  0,  0],
        [30, 31, 32,  0,  0],
        [35, 36, 37, 38,  0]],
       [[40,  0,  0,  0,  0],
        [45, 46,  0,  0,  0],
        [50, 51, 52,  0,  0],
        [55, 56, 57, 58,  0]]])</pre> 
</div>
</div>
<a id="a2b716112412d6d2a7d5c6d62479ab0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b716112412d6d2a7d5c6d62479ab0f8">&#9670;&nbsp;</a></span>tril_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.tril_indices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices for the lower-triangle of an (n, m) array.

Parameters
----------
n : int
    The row dimension of the arrays for which the returned
    indices will be valid.
k : int, optional
    Diagonal offset (see `tril` for details).
m : int, optional
    .. versionadded:: 1.9.0

    The column dimension of the arrays for which the returned
    arrays will be valid.
    By default `m` is taken equal to `n`.


Returns
-------
inds : tuple of arrays
    The indices for the triangle. The returned tuple contains two arrays,
    each with the indices along one dimension of the array.

See also
--------
triu_indices : similar function, for upper-triangular.
mask_indices : generic function accepting an arbitrary mask function.
tril, triu

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
Compute two different sets of indices to access 4x4 arrays, one for the
lower triangular part starting at the main diagonal, and one starting two
diagonals further right:

&gt;&gt;&gt; il1 = np.tril_indices(4)
&gt;&gt;&gt; il2 = np.tril_indices(4, 2)

Here is how they can be used with a sample array:

&gt;&gt;&gt; a = np.arange(16).reshape(4, 4)
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

Both for indexing:

&gt;&gt;&gt; a[il1]
array([ 0,  4,  5, ..., 13, 14, 15])

And for assigning values:

&gt;&gt;&gt; a[il1] = -1
&gt;&gt;&gt; a
array([[-1,  1,  2,  3],
       [-1, -1,  6,  7],
       [-1, -1, -1, 11],
       [-1, -1, -1, -1]])

These cover almost the whole array (two diagonals right of the main one):

&gt;&gt;&gt; a[il2] = -10
&gt;&gt;&gt; a
array([[-10, -10, -10,   3],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10]])</pre> 
</div>
</div>
<a id="acf3be40e3614389bdaded615b72aa5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3be40e3614389bdaded615b72aa5e0">&#9670;&nbsp;</a></span>tril_indices_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.tril_indices_from </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices for the lower-triangle of arr.

See `tril_indices` for full details.

Parameters
----------
arr : array_like
    The indices will be valid for square arrays whose dimensions are
    the same as arr.
k : int, optional
    Diagonal offset (see `tril` for details).

See Also
--------
tril_indices, tril

Notes
-----
.. versionadded:: 1.4.0</pre> 
</div>
</div>
<a id="ad4c5f72467e0719ef3b6e8e9a1aad2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c5f72467e0719ef3b6e8e9a1aad2cd">&#9670;&nbsp;</a></span>triu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.triu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Upper triangle of an array.

Return a copy of an array with the elements below the `k`-th diagonal
zeroed. For arrays with ``ndim`` exceeding 2, `triu` will apply to the
final two axes.

Please refer to the documentation for `tril` for further details.

See Also
--------
tril : lower triangle of an array

Examples
--------
&gt;&gt;&gt; np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12]])

&gt;&gt;&gt; np.triu(np.arange(3*4*5).reshape(3, 4, 5))
array([[[ 0,  1,  2,  3,  4],
        [ 0,  6,  7,  8,  9],
        [ 0,  0, 12, 13, 14],
        [ 0,  0,  0, 18, 19]],
       [[20, 21, 22, 23, 24],
        [ 0, 26, 27, 28, 29],
        [ 0,  0, 32, 33, 34],
        [ 0,  0,  0, 38, 39]],
       [[40, 41, 42, 43, 44],
        [ 0, 46, 47, 48, 49],
        [ 0,  0, 52, 53, 54],
        [ 0,  0,  0, 58, 59]]])</pre> 
</div>
</div>
<a id="ab3a38f5d340ce47aebc8046a4d7d57d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a38f5d340ce47aebc8046a4d7d57d7">&#9670;&nbsp;</a></span>triu_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.triu_indices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices for the upper-triangle of an (n, m) array.

Parameters
----------
n : int
    The size of the arrays for which the returned indices will
    be valid.
k : int, optional
    Diagonal offset (see `triu` for details).
m : int, optional
    .. versionadded:: 1.9.0

    The column dimension of the arrays for which the returned
    arrays will be valid.
    By default `m` is taken equal to `n`.


Returns
-------
inds : tuple, shape(2) of ndarrays, shape(`n`)
    The indices for the triangle. The returned tuple contains two arrays,
    each with the indices along one dimension of the array.  Can be used
    to slice a ndarray of shape(`n`, `n`).

See also
--------
tril_indices : similar function, for lower-triangular.
mask_indices : generic function accepting an arbitrary mask function.
triu, tril

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
Compute two different sets of indices to access 4x4 arrays, one for the
upper triangular part starting at the main diagonal, and one starting two
diagonals further right:

&gt;&gt;&gt; iu1 = np.triu_indices(4)
&gt;&gt;&gt; iu2 = np.triu_indices(4, 2)

Here is how they can be used with a sample array:

&gt;&gt;&gt; a = np.arange(16).reshape(4, 4)
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

Both for indexing:

&gt;&gt;&gt; a[iu1]
array([ 0,  1,  2, ..., 10, 11, 15])

And for assigning values:

&gt;&gt;&gt; a[iu1] = -1
&gt;&gt;&gt; a
array([[-1, -1, -1, -1],
       [ 4, -1, -1, -1],
       [ 8,  9, -1, -1],
       [12, 13, 14, -1]])

These cover only a small part of the whole array (two diagonals right
of the main one):

&gt;&gt;&gt; a[iu2] = -10
&gt;&gt;&gt; a
array([[ -1,  -1, -10, -10],
       [  4,  -1,  -1, -10],
       [  8,   9,  -1,  -1],
       [ 12,  13,  14,  -1]])</pre> 
</div>
</div>
<a id="aaa286c33b12fe305ea9ead63f3f25f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa286c33b12fe305ea9ead63f3f25f38">&#9670;&nbsp;</a></span>triu_indices_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.triu_indices_from </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices for the upper-triangle of arr.

See `triu_indices` for full details.

Parameters
----------
arr : ndarray, shape(N, N)
    The indices will be valid for square arrays.
k : int, optional
    Diagonal offset (see `triu` for details).

Returns
-------
triu_indices_from : tuple, shape(2) of ndarray, shape(N)
    Indices for the upper-triangle of `arr`.

See Also
--------
triu_indices, triu

Notes
-----
.. versionadded:: 1.4.0</pre> 
</div>
</div>
<a id="a2aaf8cbe0cc568d958fd0ec603b94677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aaf8cbe0cc568d958fd0ec603b94677">&#9670;&nbsp;</a></span>vander()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.twodim_base.vander </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>increasing</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a Vandermonde matrix.

The columns of the output matrix are powers of the input vector. The
order of the powers is determined by the `increasing` boolean argument.
Specifically, when `increasing` is False, the `i`-th output column is
the input vector raised element-wise to the power of ``N - i - 1``. Such
a matrix with a geometric progression in each row is named for Alexandre-
Theophile Vandermonde.

Parameters
----------
x : array_like
    1-D input array.
N : int, optional
    Number of columns in the output.  If `N` is not specified, a square
    array is returned (``N = len(x)``).
increasing : bool, optional
    Order of the powers of the columns.  If True, the powers increase
    from left to right, if False (the default) they are reversed.

    .. versionadded:: 1.9.0

Returns
-------
out : ndarray
    Vandermonde matrix.  If `increasing` is False, the first column is
    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is
    True, the columns are ``x^0, x^1, ..., x^(N-1)``.

See Also
--------
polynomial.polynomial.polyvander

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 3, 5])
&gt;&gt;&gt; N = 3
&gt;&gt;&gt; np.vander(x, N)
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

&gt;&gt;&gt; np.column_stack([x**(N-1-i) for i in range(N)])
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

&gt;&gt;&gt; x = np.array([1, 2, 3, 5])
&gt;&gt;&gt; np.vander(x)
array([[  1,   1,   1,   1],
       [  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [125,  25,   5,   1]])
&gt;&gt;&gt; np.vander(x, increasing=True)
array([[  1,   1,   1,   1],
       [  1,   2,   4,   8],
       [  1,   3,   9,  27],
       [  1,   5,  25, 125]])

The determinant of a square Vandermonde matrix is the product
of the differences between the values of the input vector:

&gt;&gt;&gt; np.linalg.det(np.vander(x))
48.000000000000043 # may vary
&gt;&gt;&gt; (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
48</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a12fefeaaa42281321c1a4d46f5466e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fefeaaa42281321c1a4d46f5466e78">&#9670;&nbsp;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.twodim_base.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  functools.partial(</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    overrides.array_function_dispatch, module=<span class="stringliteral">&#39;numpy&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
