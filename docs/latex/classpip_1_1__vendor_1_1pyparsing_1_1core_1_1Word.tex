\hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word}{}\doxysection{pip.\+\_\+vendor.\+pyparsing.\+core.\+Word Class Reference}
\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word}\index{pip.\_vendor.pyparsing.core.Word@{pip.\_vendor.pyparsing.core.Word}}


Inheritance diagram for pip.\+\_\+vendor.\+pyparsing.\+core.\+Word\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=256pt]{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for pip.\+\_\+vendor.\+pyparsing.\+core.\+Word\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a7b6a31c82ecf1703b0fe6a0d154a4bb3}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a7b6a31c82ecf1703b0fe6a0d154a4bb3}} 
def {\bfseries \+\_\+\+\_\+init\+\_\+\+\_\+} (self, str init\+\_\+chars=\char`\"{}\char`\"{}, Optional\+Type\mbox{[}str\mbox{]} body\+\_\+chars=None, int min=1, int max=0, int exact=0, bool as\+\_\+keyword=False, Optional\+Type\mbox{[}str\mbox{]} exclude\+\_\+chars=None, $\ast$Optional\+Type\mbox{[}str\mbox{]} init\+Chars=None, Optional\+Type\mbox{[}str\mbox{]} body\+Chars=None, bool as\+Keyword=False, Optional\+Type\mbox{[}str\mbox{]} exclude\+Chars=None)
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a973f0b3c75b2f101e887967c7c5fcdc9}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a973f0b3c75b2f101e887967c7c5fcdc9}} 
def {\bfseries parse\+Impl} (self, instring, loc, do\+Actions=True)
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a933a537db9cd2db2ded95c572fbd1c38}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a933a537db9cd2db2ded95c572fbd1c38}} 
{\bfseries init\+Chars}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a77e8694cfd58f09f4b682a93a1d172cb}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a77e8694cfd58f09f4b682a93a1d172cb}} 
{\bfseries init\+Chars\+Orig}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_acc152fc5f3e96877a26027fc0637f486}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_acc152fc5f3e96877a26027fc0637f486}} 
{\bfseries body\+Chars\+Orig}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_aa302e172cf8bde1e0b614a2b966f418f}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_aa302e172cf8bde1e0b614a2b966f418f}} 
{\bfseries body\+Chars}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a3dbc52be61f0dbde79cb63963f1e9993}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a3dbc52be61f0dbde79cb63963f1e9993}} 
{\bfseries max\+Specified}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a6499cb4e24795f9f831f7d784a9630ae}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a6499cb4e24795f9f831f7d784a9630ae}} 
{\bfseries min\+Len}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a7ac11763a106f055feae9041da3b0226}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a7ac11763a106f055feae9041da3b0226}} 
{\bfseries max\+Len}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a68080ae37cda9f81217eb5dfec9af09b}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a68080ae37cda9f81217eb5dfec9af09b}} 
{\bfseries errmsg}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a64e4c72f8e487b1fc7a16e77f6cf79fc}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a64e4c72f8e487b1fc7a16e77f6cf79fc}} 
{\bfseries may\+Index\+Error}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a6f20f0c0ec51c4ba7ed823bd4b311dc0}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a6f20f0c0ec51c4ba7ed823bd4b311dc0}} 
{\bfseries as\+Keyword}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_afa8de5d20d60723cbca652ebfa618e53}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_afa8de5d20d60723cbca652ebfa618e53}} 
{\bfseries re\+String}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a8b640cc30bd10e691b40fd92cbca6919}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_a8b640cc30bd10e691b40fd92cbca6919}} 
{\bfseries re}
\item 
\mbox{\Hypertarget{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_ada26d5d8daf9940c7e0306183ec4635f}\label{classpip_1_1__vendor_1_1pyparsing_1_1core_1_1Word_ada26d5d8daf9940c7e0306183ec4635f}} 
{\bfseries re\+\_\+match}
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Token for matching words composed of allowed character sets.
Parameters:
- ``init_chars`` - string of all characters that should be used to
  match as a word; "ABC" will match "AAA", "ABAB", "CBAC", etc.;
  if ``body_chars`` is also specified, then this is the string of
  initial characters
- ``body_chars`` - string of characters that
  can be used for matching after a matched initial character as
  given in ``init_chars``; if omitted, same as the initial characters
  (default=``None``)
- ``min`` - minimum number of characters to match (default=1)
- ``max`` - maximum number of characters to match (default=0)
- ``exact`` - exact number of characters to match (default=0)
- ``as_keyword`` - match as a keyword (default=``False``)
- ``exclude_chars`` - characters that might be
  found in the input ``body_chars`` string but which should not be
  accepted for matching ;useful to define a word of all
  printables except for one or two characters, for instance
  (default=``None``)

:class:`srange` is useful for defining custom character set strings
for defining :class:`Word` expressions, using range notation from
regular expression character sets.

A common mistake is to use :class:`Word` to match a specific literal
string, as in ``Word("Address")``. Remember that :class:`Word`
uses the string argument to define *sets* of matchable characters.
This expression would match "Add", "AAA", "dAred", or any other word
made up of the characters 'A', 'd', 'r', 'e', and 's'. To match an
exact literal string, use :class:`Literal` or :class:`Keyword`.

pyparsing includes helper strings for building Words:

- :class:`alphas`
- :class:`nums`
- :class:`alphanums`
- :class:`hexnums`
- :class:`alphas8bit` (alphabetic characters in ASCII range 128-255
  - accented, tilded, umlauted, etc.)
- :class:`punc8bit` (non-alphabetic characters in ASCII range
  128-255 - currency, symbols, superscripts, diacriticals, etc.)
- :class:`printables` (any non-whitespace character)

``alphas``, ``nums``, and ``printables`` are also defined in several
Unicode sets - see :class:`pyparsing_unicode``.

Example::

    # a word composed of digits
    integer = Word(nums) # equivalent to Word("0123456789") or Word(srange("0-9"))

    # a word with a leading capital, and zero or more lowercase
    capital_word = Word(alphas.upper(), alphas.lower())

    # hostnames are alphanumeric, with leading alpha, and '-'
    hostname = Word(alphas, alphanums + '-')

    # roman numeral (not a strict parser, accepts invalid mix of characters)
    roman = Word("IVXLCDM")

    # any string of non-whitespace characters, except for ','
    csv_value = Word(printables, exclude_chars=",")
\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
inventaria\+\_\+env/lib/python3.\+10/site-\/packages/pip/\+\_\+vendor/pyparsing/core.\+py\end{DoxyCompactItemize}
